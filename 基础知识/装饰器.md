# 装饰器

## 装饰器是什么

装饰器本质是一个函数，接受函数作为参数，根据传入的函数定义一个新函数

**基本框架**
``` python
def decorator(func)
  def wrapper(*args,**kwargs):

    result = func(*args,**kwargs) #原本func的功能

    return result #原本func的功能
  return warpper

```

装饰器是闭包的一种应用，’装饰’代指为被装饰对象添加新的功能，’器’代指器具/工具，装饰器与被装饰的对象均可以是任意可调用对象。概括地讲，装饰器的作用就是在不修改被装饰对象源代码和调用方式的前提下为被装饰对象添加额外的功能。装饰器经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等应用场景，装饰器是解决这类问题的绝佳设计，有了装饰器，就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。

提示：可调用对象有函数，方法或者类，此处我们单以本章主题函数为例，来介绍函数装饰器，并且被装饰的对象也是函数。

## 为什么

软件的设计应该遵循**开放封闭原则**，即对扩展是开放的，而对修改是封闭的。对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。对修改封闭，意味着对象一旦设计完成，就可以独立完成其工作，而不要对其进行修改。

软件包含的所有功能的源代码以及调用方式，都应该避免修改，否则一旦改错，则极有可能产生连锁反应，最终导致程序崩溃，而对于上线后的软件，新需求或者变化又层出不穷，我们必须为程序提供扩展的可能性，这就用到了装饰器。

**装饰器的主要特点包括**：

1. 不修改已有函数的源代码：装饰器不会改变被装饰函数的源代码，只是在其外部进行包裹或扩展。
2. 不修改已有函数的调用方式：使用装饰器后，调用被装饰函数的方式仍然保持不变。
3. 给已有函数增加额外的功能：这是装饰器的主要目的，通过在已有函数外部添加新的逻辑，实现功能的扩展。

# 实现装饰器

@dec后接func函数定义 **完全等价于** func = dec(func)

1. 定义函数

2. 添加闭包
   
  ```PYTHON
  def outter(func)
    def wrapper(*args,**kwargs):
      # 添加的功能
      func(*args,**kwargs)

      res=func(*args,**kwargs)
      return res # 返回和func相同的值

    return wrapper
  ```

3. 同名调用
   ```
  func=outter(func)
  func()

   ```

# 语法糖：省事的语法

先定义装饰器

在被装饰的函数对象正上方的单独一行写 **@装饰器名字**
等价于 原函数名=装饰器名(原函数名)

可以叠加多个装饰器

# 进一步伪装:使用warps模块设置函数属性

在装饰器的定义阶段对函数的属性进行设置
例如：

```
wapper.__doc__ = index.__doc__
```

当然，属性非常多，一个一个设置不显示，所以有以下将原函数的属性值给wrapper函数的方法：

```
from functions import warps

//在warpper函数上分加一行：

@warps
  def wrapper(*args,**kwargs):

```

# 有参装饰器

dec装饰器函数有多个参数怎么办？语法糖@只接受1个参数
可以自己写，但是麻烦

可以在原装饰器外再套一层函数，该函数可以接受多个参数

```
def auth(db_type):
  def deco(func)...
  return deco

@auth(db_type = "file")

```

# 多装饰器叠加

加载顺序自下而上，执行顺序自上而下 wrapper1 -> wrapper2   -> wrapper3

```
@deco1 //wrapper1
@deco2 //wrapper2
@deco3 //wrapper3
def index():...

```
index = wrapper1的内存地址
